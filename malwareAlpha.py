#The script is a malware analysis tool that takes a file path as input and performs various analysis tasks on the specified file. 
#The script uses several command-line tools and interacts with the VirusTotal API to gather information about the file. 
#It specifically analyzes PE executables, Microsoft Office files, and PDFs. 
#Notably, the script does not automatically extract embedded files; this task necessitates manual intervention from the user. 
#The script outputs crucial information essential for static malware analysis and queries the Virustotal database using the file's hash. 
#It is crucial to note that the script is not designed to function as an antivirus tool; it does not provide a definitive verdict on whether the file is malicious or not. 
#Further investigation by the user is essential for making such determinations.



import sys
import subprocess
import hashlib
from vt import Client
import json
import argparse

# ANSI escape codes for colors
GREEN = '\033[92m'
RED = '\033[91m'
RESET = '\033[0m'
YELLOW = '\033[93m'


#     1968cbab83f9796517e3670f8f86c45c9d5f99f0e783579aae712753b63912b5


def colored_print(message, color):
    print(color + message + RESET)
    
def run_bash_commands(file_path, bash_command):
    try:
        colored_print(f"\nCommand executed: {bash_command} ====================================================================", RED)
        subprocess.run(bash_command, shell=True, check=True)
    except FileNotFoundError:
        print(f"Error: File not found - {file_path}")
    except subprocess.CalledProcessError as e:
        print(f"Error: Bash command failed - {e}")

def format_and_print_response(response):
# Convert the response to a formatted JSON string with indentation
    json_response = json.dumps(response.to_dict(), indent=2)
    colored_print(f'\nVirusTotal Report:\n{json_response}', GREEN)


def main():
    parser = argparse.ArgumentParser(description='Malware analysis script')
    parser.add_argument('file_path', help='Path to the file for analysis')
    parser.add_argument('--key',  help='VirusTotal API Key')

    args = parser.parse_args()


    file_path = args.file_path
    VIRUSTOTAL_API_KEY = args.key

# Define the Bash commands
    bash_command = "file"
   
# Run the Bash command
    run_bash_commands(file_path, f"{bash_command} {file_path}")

# Initialize VirusTotal Client
    vt = None

    if VIRUSTOTAL_API_KEY:
        vt = Client(VIRUSTOTAL_API_KEY)

# Check the output for a specific string
    try:
        output = subprocess.check_output([bash_command, file_path], text=True)
        file_hash = hashlib.sha256(open(file_path, 'rb').read()).hexdigest()

    

        if 'exe' in output:
            colored_print("\nSpecific string found in the output: The file is an executable", RED)
      
# Define a new list of Bash commands to run
            additional_commands = [
            f'exiftool {file_path}',
            f'strings {file_path} | grep -E ".exe|Microsoft|Reg|Windows|url|URL|.dll|.DLL|DOS|IP|Ip|Url|Remote|Access|System|SYSTEM|HARDWARE|Hardware|Write|Create|Delete|Read|Win|SOFTWARE|Software|User|http|WINDOWS|MICROSOFT"',
            f'yara -w /usr/local/yara-rules/index.yar {file_path}',
            f'xorsearch {file_path} http',
            f'floss --no static -- {file_path}',
            
	    
            # Add more commands as needed
            ]

# Run the additional Bash commands
            for command in additional_commands:
                run_bash_commands(file_path, command)
        
	
        
	
        elif 'Microsoft' in output:
            colored_print("\nSpecific string found in the output: The file is a Microsoft Office", RED)
      
# Define a new list of Bash commands to run
            additional_commands = [
            f'exiftool {file_path}',
            f'strings {file_path} | grep -E ".exe|Microsoft|Reg|Windows|url|URL|.dll|.DLL|DOS|IP|Ip|Url|Remote|Access|System|SYSTEM|HARDWARE|Hardware|Write|Create|Delete|Read|Win|SOFTWARE|Software|User|http|WINDOWS|MICROSOFT"',
            f'yara -w /usr/local/yara-rules/index.yar {file_path}',
            f'xorsearch {file_path} http',
            f'oleid {file_path}',
            f'olevba {file_path}',
            f'oledir {file_path}',
            
	    
            # Add more commands as needed
            ]

# Run the additional Bash commands
            for command in additional_commands:
                run_bash_commands(file_path, command)
	
	
        elif 'PDF' in output:
            colored_print("\nSpecific string found in the output: The file is a PDF", RED)
      
# Define a new list of Bash commands to run
            additional_commands = [
            f'exiftool {file_path}',
            f'strings {file_path} | grep -E ".exe|Microsoft|Reg|Windows|url|URL|.dll|.DLL|DOS|IP|Ip|Url|Remote|Access|System|SYSTEM|HARDWARE|Hardware|Write|Create|Delete|Read|Win|SOFTWARE|Software|User|http|WINDOWS|MICROSOFT"',
            f'yara -w /usr/local/yara-rules/index.yar {file_path}',
            f'xorsearch {file_path} http',
            f'pdfid.py {file_path}',
            f'peepdf -f {file_path}',
            
	    
            # Add more commands as needed
            ]

# Run the additional Bash commands
            for command in additional_commands:
                run_bash_commands(file_path, command)
            colored_print('\nYou can use pdf-parser tool to extract embedded files', YELLOW)
        
	
        else:
            colored_print("Specific string not found in the output.", RED)

# Use vt-py to interact with VirusTotal
        if vt: 
            response = vt.get_object(f"/files/{file_hash}")
            format_and_print_response(response)

    except subprocess.CalledProcessError as e:
        print(f"Error: Bash command failed - {e}")

    finally:
        if vt:
            # Close the VirusTotal client session explicitly
            vt.close()

        colored_print(f'\nYou can visit the Virustotal website report here --- https://www.virustotal.com/gui/file/{file_hash} ---', RED)



if __name__ == "__main__":
    main()
